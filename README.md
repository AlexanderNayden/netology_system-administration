# Домашнее задание к занятию "`Базы данных, их типы`" - `Найден Александр`


## Задание 1. СУБД


### 1.1. Бюджетирование и финансовые отчёты
**СУБД:** `PostgreSQL`  
**Обоснование:** ACID-транзакции, строгая схема данных, аналитические возможности (OLAP)  
**Решение 1.1\*:** Оптимизация через `pgcrypto` или облачные сервисы (AWS KMS/Azure Key Vault)


### 1.2. Лендинги и CRM
**Основное решение:** `PostgreSQL` для CRM + `MongoDB` для лендингов  
**Альтернатива:** Одна `PostgreSQL` с использованием `JSONB` для данных лендингов  
**Обоснование:** Сочетание структуры CRM и гибкости для лидов


### 1.3. База знаний и нормативов
**СУБД:** `PostgreSQL`  
**Реализация:** Таблицы с `parent_id` + рекурсивные запросы (`WITH RECURSIVE`)  
**Решение 1.3\*:** Да, использовать существующую PostgreSQL


### 1.4. Логистика и маршрутизация
**СУБД:** `Neo4j` (графовая БД)  
**Обоснование:** Оптимально для поиска кратчайших путей и сложных связей  
**Решение 1.4\*:** Закупки — отдельная `PostgreSQL`, связанная через API

###

### Универсальное решение (1.5*)
**Ответ:** Можно использовать одну `PostgreSQL` для всех задач, но для логистики — компромисс в производительности.  
**Рекомендация:** Гибридная архитектура `PostgreSQL` + `Neo4j`


### Итоговая архитектура

- Финансы (1.1) → `PostgreSQL`
- CRM (1.2) → `PostgreSQL`
- Лендинги (1.2) → `MongoDB` (или `PostgreSQL` с `JSONB`)
- База знаний (1.3) → `PostgreSQL`
- Логистика (1.4) → `Neo4j`
####
- Закупки (1.5*) → `PostgreSQL`

---

## Задание 2. Транзакции

# Транзакции при пополнении баланса телефона

### 2.1. Пополнение баланса счёта телефона

1. **Начало транзакции** - блокировка данных, начало операции
2. **Валидация реквизитов** - проверка номера карты/кошелька, достаточности средств
3. **Списание с источника** - уменьшение баланса карты/электронного кошелька
4. **Зачисление на телефон** - увеличение баланса телефонного номера
5. **Фиксация в истории** - запись операции в базу данных
6. **Завершение транзакции** - подтверждение успеха, разблокировка данных

###

### 2.1.* Пополнение через автоплатёж

1. **Проверка условий** - дата срабатывания, статус услуги, минимальный баланс
2. **Валидация реквизитов** - проверка актуальности привязанной карты/счёта
3. **Авторизация операции** - подтверждение списания у платёжного провайдера
4. **Выполнение платежа** - списание с карты → зачисление на телефон
5. **Уведомление пользователя** - отправка SMS/email-подтверждения
6. **Обновление данных** - запись даты следующего списания, статистики

---

## Задание 3. SQL vs NoSQL

### 3.1. Преимущества SQL над NoSQL

1. **Гарантированная целостность данных** - строгая ACID-совместимость
2. **Стандартизированный язык запросов** - единый SQL синтаксис across разных СУБД
3. **Сложные JOIN-запросы** - эффективная работа со связанными данными
4. **Жёсткая схема данных** - предсказуемая структура и валидация на уровне БД
5. **Мощные аналитические возможности** - оконные функции, сложные агрегации

###

### 3.1.* Преимущества NewSQL

### Над SQL:
- **Горизонтальное масштабирование** - шардинг "из коробки"
- **Высокая производительность** - оптимизированная для OLTP-нагрузок
- **Распределённые транзакции** - ACID в распределённой среде

### Над NoSQL:
- **Полная ACID-поддержка** - без компромиссов в целостности
- **SQL-совместимость** - знакомый язык запросов
- **Структурированные данные** - строгая схема при распределённой архитектуре

**Примеры:** Google Spanner, CockroachDB, VoltDB

---

## Задание 4. Кластеры

### Критерии выбора СУБД

1. **Модель согласованности** - выбор между строгой целостностью (ACID) и eventual consistency
2. **Тип рабочей нагрузки** - OLTP (транзакции) vs OLAP (аналитика)
3. **Структура данных** - структурированные vs полу структурированные/неструктурированные
4. **Требования к задержкам** - real-time vs batch processing
5. **Горизонтальное масштабирование** - поддержка шардинга и репликации

### Рекомендуемая модель вычислений

**MapReduce + MPP (Massively Parallel Processing)**

### Почему MapReduce:
- **Распределение нагрузки** - автоматическое разделение данных на 1000 машин
- **Отказоустойчивость** - перераспределение задач при сбоях узлов
- **Обработка любых объёмов** - линейная масштабируемость

### Почему MPP:
- **Высокая скорость** - параллельное выполнение запросов на всех узлах
- **Сложная аналитика** - оптимизация для агрегаций и JOIN-ов
- **SQL-интерфейс** - знакомый инструмент для аналитиков

### Оптимальное решение

**СУБД:** **ClickHouse** или **Apache Spark + Hadoop**
- Column-oriented хранилище для аналитики
- MPP-архитектура
- Поддержка SQL-интерфейса
- Горизонтальное масштабирование на 1000+ узлов